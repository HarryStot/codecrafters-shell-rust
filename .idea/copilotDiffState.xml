<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/command.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/command.rs" />
              <option name="originalContent" value="use error::CommandError;&#10;&#10;pub(crate) mod echo;&#10;pub(crate) mod error;&#10;pub(crate) mod exit;&#10;pub(crate) mod external;&#10;pub(crate) mod typee;&#10;pub(crate) mod pwd;&#10;mod cd;&#10;pub(crate) mod utils; // extracted shared utilities&#10;&#10;pub enum Command {&#10;    Noop,&#10;    Exit(i32),&#10;    Echo(String),&#10;    Type(String),&#10;    Pwd,&#10;    Cd(String),&#10;    External {&#10;        cmd: String,&#10;        args: Vec&lt;String&gt;,&#10;        path: String,&#10;    }&#10;}&#10;&#10;impl Command {&#10;    pub fn execute(&amp;self) {&#10;        use Command::*;&#10;        match self {&#10;            Noop =&gt; (),&#10;            Exit(code) =&gt; exit::exit_cmd(*code),&#10;            Echo(message) =&gt; echo::echo_cmd(message),&#10;            Type(cmd) =&gt; typee::type_cmd(cmd),&#10;            Pwd =&gt; pwd::pwd_cmd(),&#10;            Cd(path) =&gt; cd::cd_cmd(path),&#10;            External { .. } =&gt; external::external_cmd(self),&#10;        }&#10;    }&#10;&#10;    pub fn from(input: &amp;str) -&gt; Result&lt;Command, CommandError&gt; {&#10;        use Command::*;&#10;        // let input = input.trim().splitn(2, ' ').collect::&lt;Vec&lt;&amp;str&gt;&gt;();&#10;        // let cmd = input.first().copied().unwrap_or(&quot;&quot;);&#10;        // let args_raw = input.get(1).copied().unwrap_or(&quot;&quot;);&#10;        // let args = utils::preprocess_args(args_raw);&#10;        let input = input.trim();&#10;        let input_tokens = utils::split_args(input);&#10;        eprintln!(&quot;DEBUG Command::from: input={:?} tokens={:?}&quot;, input, input_tokens);&#10;        let cmd = input_tokens.first().map(|s| s.as_str()).unwrap_or(&quot;&quot;);&#10;        let args_tokens: Vec&lt;String&gt; = if input_tokens.len() &gt; 1 {&#10;            input_tokens[1..].to_vec()&#10;        } else {&#10;            Vec::new()&#10;        };&#10;        let args_for_builtins = if args_tokens.is_empty() {&#10;            String::new()&#10;        } else {&#10;            args_tokens.join(&quot; &quot;)&#10;        };&#10;&#10;        Ok(match cmd {&#10;            &quot;&quot; =&gt; Noop,&#10;            &quot;echo&quot; =&gt; echo::parse_echo_cmd(&amp;args_for_builtins)?,&#10;            &quot;exit&quot; =&gt; exit::parse_exit_cmd(&amp;args_for_builtins)?,&#10;            &quot;type&quot; =&gt; typee::parse_type_cmd(&amp;args_for_builtins)?,&#10;            &quot;pwd&quot; =&gt; pwd::parse_pwd_cmd(&amp;args_for_builtins)?,&#10;            &quot;cd&quot; =&gt; cd::parse_cd_cmd(&amp;args_for_builtins)?,&#10;            _ =&gt; match external::parse_external_cmd(cmd, args_tokens) {&#10;                Some(cmd) =&gt; cmd,&#10;                None =&gt; return Err(CommandError::NotFound(cmd.to_string())),&#10;            },&#10;        })&#10;    }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="use error::CommandError;&#10;&#10;pub(crate) mod echo;&#10;pub(crate) mod error;&#10;pub(crate) mod exit;&#10;pub(crate) mod external;&#10;pub(crate) mod typee;&#10;pub(crate) mod pwd;&#10;mod cd;&#10;pub(crate) mod utils; // extracted shared utilities&#10;&#10;pub enum Command {&#10;    Noop,&#10;    Exit(i32),&#10;    Echo(String),&#10;    Type(String),&#10;    Pwd,&#10;    Cd(String),&#10;    External {&#10;        cmd: String,&#10;        args: Vec&lt;String&gt;,&#10;        path: String,&#10;    }&#10;}&#10;&#10;impl Command {&#10;    pub fn execute(&amp;self) {&#10;        use Command::*;&#10;        match self {&#10;            Noop =&gt; (),&#10;            Exit(code) =&gt; exit::exit_cmd(*code),&#10;            Echo(message) =&gt; echo::echo_cmd(message),&#10;            Type(cmd) =&gt; typee::type_cmd(cmd),&#10;            Pwd =&gt; pwd::pwd_cmd(),&#10;            Cd(path) =&gt; cd::cd_cmd(path),&#10;            External { .. } =&gt; external::external_cmd(self),&#10;        }&#10;    }&#10;&#10;    pub fn from(input: &amp;str) -&gt; Result&lt;Command, CommandError&gt; {&#10;        use Command::*;&#10;        // let input = input.trim().splitn(2, ' ').collect::&lt;Vec&lt;&amp;str&gt;&gt;();&#10;        // let cmd = input.first().copied().unwrap_or(&quot;&quot;);&#10;        // let args_raw = input.get(1).copied().unwrap_or(&quot;&quot;);&#10;        // let args = utils::preprocess_args(args_raw);&#10;        let input = input.trim();&#10;        let input_tokens = utils::split_args(input);&#10;        eprintln!(&quot;DEBUG Command::from: input={:?} tokens={:?}&quot;, input, input_tokens);&#10;        let cmd = input_tokens.first().map(|s| s.as_str()).unwrap_or(&quot;&quot;);&#10;        let args_tokens: Vec&lt;String&gt; = if input_tokens.len() &gt; 1 {&#10;            input_tokens[1..].to_vec()&#10;        } else {&#10;            Vec::new()&#10;        };&#10;        let args_for_builtins = if args_tokens.is_empty() {&#10;            String::new()&#10;        } else {&#10;            args_tokens.join(&quot; &quot;)&#10;        };&#10;&#10;        Ok(match cmd {&#10;            &quot;&quot; =&gt; Noop,&#10;            &quot;echo&quot; =&gt; echo::parse_echo_cmd(&amp;args_for_builtins)?,&#10;            &quot;exit&quot; =&gt; exit::parse_exit_cmd(&amp;args_for_builtins)?,&#10;            &quot;type&quot; =&gt; typee::parse_type_cmd(&amp;args_for_builtins)?,&#10;            &quot;pwd&quot; =&gt; pwd::parse_pwd_cmd(&amp;args_for_builtins)?,&#10;            &quot;cd&quot; =&gt; cd::parse_cd_cmd(&amp;args_for_builtins)?,&#10;            _ =&gt; match external::parse_external_cmd(cmd, args_tokens) {&#10;                Some(cmd) =&gt; cmd,&#10;                None =&gt; return Err(CommandError::NotFound(cmd.to_string())),&#10;            },&#10;        })&#10;    }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/command/external.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/command/external.rs" />
              <option name="originalContent" value="use super::Command::{self, *};&#10;use std::{io, io::Write, process::Command as StdCommand};&#10;use std::os::unix::fs::PermissionsExt;&#10;use std::os::unix::process::CommandExt;&#10;&#10;pub(crate) fn external_cmd(cmd: &amp;Command) {&#10;    let External { cmd: cmd_name, args, path, .. } = cmd else {&#10;        eprintln!(&quot;Unexpected error occurred while executing external command&quot;);&#10;        return;&#10;    };&#10;    let output = StdCommand::new(path)&#10;        .arg0(cmd_name)&#10;        .args(args.iter())&#10;        .output()&#10;        .expect(&quot;failed to execute process&quot;);&#10;    io::stdout().write_all(&amp;output.stdout).unwrap();&#10;    io::stderr().write_all(&amp;output.stderr).unwrap();&#10;}&#10;&#10;// parse_external_cmd now receives tokenized args (Vec&lt;String&gt;) produced by utils::split_args&#10;pub(crate) fn parse_external_cmd(cmd: &amp;str, args_tokens: Vec&lt;String&gt;) -&gt; Option&lt;Command&gt; {&#10;    let path_env = std::env::var_os(&quot;PATH&quot;)?;&#10;    std::env::split_paths(&amp;path_env)&#10;        .map(|p| p.join(cmd))&#10;        .find(|full_path| {&#10;            full_path.metadata()&#10;                .map(|m| m.is_file() &amp;&amp; m.permissions().mode() &amp; 0o111 != 0)&#10;                .unwrap_or(false)&#10;        })&#10;        .map(|path_buf| External {&#10;            cmd: cmd.to_string(),&#10;            args: args_tokens,&#10;            path: path_buf.to_string_lossy().to_string(),&#10;        })&#10;}&#10;" />
              <option name="updatedContent" value="use super::Command::{self, *};&#10;use std::{io, io::Write, process::Command as StdCommand};&#10;use std::os::unix::fs::PermissionsExt;&#10;use std::os::unix::process::CommandExt;&#10;&#10;pub(crate) fn external_cmd(cmd: &amp;Command) {&#10;    let External { cmd: cmd_name, args, path, .. } = cmd else {&#10;        eprintln!(&quot;Unexpected error occurred while executing external command&quot;);&#10;        return;&#10;    };&#10;    let output = StdCommand::new(path)&#10;        .arg0(cmd_name)&#10;        .args(args.iter())&#10;        .output()&#10;        .expect(&quot;failed to execute process&quot;);&#10;    io::stdout().write_all(&amp;output.stdout).unwrap();&#10;    io::stderr().write_all(&amp;output.stderr).unwrap();&#10;}&#10;&#10;// parse_external_cmd now receives tokenized args (Vec&lt;String&gt;) produced by utils::split_args&#10;pub(crate) fn parse_external_cmd(cmd: &amp;str, args_tokens: Vec&lt;String&gt;) -&gt; Option&lt;Command&gt; {&#10;    let path_env = std::env::var_os(&quot;PATH&quot;)?;&#10;    std::env::split_paths(&amp;path_env)&#10;        .map(|p| p.join(cmd))&#10;        .find(|full_path| {&#10;            full_path.metadata()&#10;                .map(|m| m.is_file() &amp;&amp; m.permissions().mode() &amp; 0o111 != 0)&#10;                .unwrap_or(false)&#10;        })&#10;        .map(|path_buf| External {&#10;            cmd: cmd.to_string(),&#10;            args: args_tokens,&#10;            path: path_buf.to_string_lossy().to_string(),&#10;        })&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>