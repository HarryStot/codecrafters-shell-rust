<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/src/command.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/command.rs" />
              <option name="originalContent" value="use error::CommandError;&#10;&#10;pub(crate) mod echo;&#10;pub(crate) mod error;&#10;pub(crate) mod exit;&#10;pub(crate) mod external;&#10;pub(crate) mod typee;&#10;pub(crate) mod pwd;&#10;mod cd;&#10;pub(crate) mod utils; // extracted shared utilities&#10;&#10;pub enum Command {&#10;    Noop,&#10;    Exit(i32),&#10;    Echo(String),&#10;    Type(String),&#10;    Pwd,&#10;    Cd(String),&#10;    External {&#10;        cmd: String,&#10;        args: Vec&lt;String&gt;,&#10;        path: String,&#10;    }&#10;}&#10;&#10;impl Command {&#10;    pub fn execute(&amp;self) {&#10;        use Command::*;&#10;        match self {&#10;            Noop =&gt; (),&#10;            Exit(code) =&gt; exit::exit_cmd(*code),&#10;            Echo(message) =&gt; echo::echo_cmd(message),&#10;            Type(cmd) =&gt; typee::type_cmd(cmd),&#10;            Pwd =&gt; pwd::pwd_cmd(),&#10;            Cd(path) =&gt; cd::cd_cmd(path),&#10;            External { .. } =&gt; external::external_cmd(self),&#10;        }&#10;    }&#10;&#10;    pub fn from(input: &amp;str) -&gt; Result&lt;Command, CommandError&gt; {&#10;        use Command::*;&#10;        let input = input.trim().splitn(2, ' ').collect::&lt;Vec&lt;&amp;str&gt;&gt;();&#10;        let cmd = input.get(0).copied().unwrap_or(&quot;&quot;);&#10;        let args_raw = input.get(1).copied().unwrap_or(&quot;&quot;);&#10;        let args = utils::preprocess_args(args_raw);&#10;&#10;        Ok(match cmd {&#10;            &quot;&quot; =&gt; Noop,&#10;            &quot;echo&quot; =&gt; echo::parse_echo_cmd(&amp;args)?,&#10;            &quot;exit&quot; =&gt; exit::parse_exit_cmd(&amp;args)?,&#10;            &quot;type&quot; =&gt; typee::parse_type_cmd(&amp;args)?,&#10;            &quot;pwd&quot; =&gt; pwd::parse_pwd_cmd(&amp;args)?,&#10;            &quot;cd&quot; =&gt; cd::parse_cd_cmd(&amp;args)?,&#10;            _ =&gt; match external::parse_external_cmd(cmd, args_raw) {&#10;                Some(cmd) =&gt; cmd,&#10;                None =&gt; return Err(CommandError::NotFound(cmd.to_string())),&#10;            },&#10;        })&#10;    }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="use error::CommandError;&#10;&#10;pub(crate) mod echo;&#10;pub(crate) mod error;&#10;pub(crate) mod exit;&#10;pub(crate) mod external;&#10;pub(crate) mod typee;&#10;pub(crate) mod pwd;&#10;mod cd;&#10;pub(crate) mod utils; // extracted shared utilities&#10;&#10;pub enum Command {&#10;    Noop,&#10;    Exit(i32),&#10;    Echo(String),&#10;    Type(String),&#10;    Pwd,&#10;    Cd(String),&#10;    External {&#10;        cmd: String,&#10;        args: Vec&lt;String&gt;,&#10;        path: String,&#10;    }&#10;}&#10;&#10;impl Command {&#10;    pub fn execute(&amp;self) {&#10;        use Command::*;&#10;        match self {&#10;            Noop =&gt; (),&#10;            Exit(code) =&gt; exit::exit_cmd(*code),&#10;            Echo(message) =&gt; echo::echo_cmd(message),&#10;            Type(cmd) =&gt; typee::type_cmd(cmd),&#10;            Pwd =&gt; pwd::pwd_cmd(),&#10;            Cd(path) =&gt; cd::cd_cmd(path),&#10;            External { .. } =&gt; external::external_cmd(self),&#10;        }&#10;    }&#10;&#10;    pub fn from(input: &amp;str) -&gt; Result&lt;Command, CommandError&gt; {&#10;        use Command::*;&#10;        let input = input.trim().splitn(2, ' ').collect::&lt;Vec&lt;&amp;str&gt;&gt;();&#10;        let cmd = input.get(0).copied().unwrap_or(&quot;&quot;);&#10;        let args_raw = input.get(1).copied().unwrap_or(&quot;&quot;);&#10;        let args = utils::preprocess_args(args_raw);&#10;&#10;        Ok(match cmd {&#10;            &quot;&quot; =&gt; Noop,&#10;            &quot;echo&quot; =&gt; echo::parse_echo_cmd(&amp;args)?,&#10;            &quot;exit&quot; =&gt; exit::parse_exit_cmd(&amp;args)?,&#10;            &quot;type&quot; =&gt; typee::parse_type_cmd(&amp;args)?,&#10;            &quot;pwd&quot; =&gt; pwd::parse_pwd_cmd(&amp;args)?,&#10;            &quot;cd&quot; =&gt; cd::parse_cd_cmd(&amp;args)?,&#10;            _ =&gt; match external::parse_external_cmd(cmd, args_raw) {&#10;                Some(cmd) =&gt; cmd,&#10;                None =&gt; return Err(CommandError::NotFound(cmd.to_string())),&#10;            },&#10;        })&#10;    }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/command/external.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/command/external.rs" />
              <option name="originalContent" value="use super::Command::{self, *};&#10;use std::{io, io::Write, process::Command as StdCommand};&#10;use std::os::unix::fs::PermissionsExt;&#10;use std::os::unix::process::CommandExt;&#10;&#10;pub(crate) fn external_cmd(cmd: &amp;Command) {&#10;    let External { cmd: cmd_name, args, path, .. } = cmd else {&#10;        eprintln!(&quot;Unexpected error occurred while executing external command&quot;);&#10;        return;&#10;    };&#10;    let output = StdCommand::new(path)&#10;        .arg0(cmd_name)&#10;        .args(args.iter())&#10;        .output()&#10;        .expect(&quot;failed to execute process&quot;);&#10;    io::stdout().write_all(&amp;output.stdout).unwrap();&#10;    io::stderr().write_all(&amp;output.stderr).unwrap();&#10;}&#10;&#10;// Note: accepts raw args (not preprocessed). This allows proper handling of single quotes&#10;// and spaces inside quoted arguments by using the dedicated splitter.&#10;pub(crate) fn parse_external_cmd(cmd: &amp;str, raw_args: &amp;str) -&gt; Option&lt;Command&gt; {&#10;    let path_env = std::env::var_os(&quot;PATH&quot;)?;&#10;    std::env::split_paths(&amp;path_env)&#10;        .map(|p| p.join(cmd))&#10;        .find(|full_path| {&#10;            full_path.metadata()&#10;                .map(|m| m.is_file() &amp;&amp; m.permissions().mode() &amp; 0o111 != 0)&#10;                .unwrap_or(false)&#10;        })&#10;        .map(|path_buf| External {&#10;            cmd: cmd.to_string(),&#10;            args: super::utils::split_args_respecting_single_quotes(raw_args),&#10;            path: path_buf.to_string_lossy().to_string(),&#10;        })&#10;}&#10;" />
              <option name="updatedContent" value="use super::Command::{self, *};&#10;use std::{io, io::Write, process::Command as StdCommand};&#10;use std::os::unix::fs::PermissionsExt;&#10;use std::os::unix::process::CommandExt;&#10;&#10;pub(crate) fn external_cmd(cmd: &amp;Command) {&#10;    let External { cmd: cmd_name, args, path, .. } = cmd else {&#10;        eprintln!(&quot;Unexpected error occurred while executing external command&quot;);&#10;        return;&#10;    };&#10;    let output = StdCommand::new(path)&#10;        .arg0(cmd_name)&#10;        .args(args.iter())&#10;        .output()&#10;        .expect(&quot;failed to execute process&quot;);&#10;    io::stdout().write_all(&amp;output.stdout).unwrap();&#10;    io::stderr().write_all(&amp;output.stderr).unwrap();&#10;}&#10;&#10;// Note: accepts raw args (not preprocessed). This allows proper handling of single quotes&#10;// and spaces inside quoted arguments by using the dedicated splitter.&#10;pub(crate) fn parse_external_cmd(cmd: &amp;str, raw_args: &amp;str) -&gt; Option&lt;Command&gt; {&#10;    let path_env = std::env::var_os(&quot;PATH&quot;)?;&#10;    std::env::split_paths(&amp;path_env)&#10;        .map(|p| p.join(cmd))&#10;        .find(|full_path| {&#10;            full_path.metadata()&#10;                .map(|m| m.is_file() &amp;&amp; m.permissions().mode() &amp; 0o111 != 0)&#10;                .unwrap_or(false)&#10;        })&#10;        .map(|path_buf| External {&#10;            cmd: cmd.to_string(),&#10;            args: super::utils::split_args_respecting_single_quotes(raw_args),&#10;            path: path_buf.to_string_lossy().to_string(),&#10;        })&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/src/command/utils.rs">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/src/command/utils.rs" />
              <option name="originalContent" value="// Shared utilities for command argument preprocessing and splitting&#10;&#10;pub(crate) fn preprocess_args(args: &amp;str) -&gt; String {&#10;    // Reuse the splitter that respects single quotes to avoid duplicating parsing logic.&#10;    // Join tokens with a single space to match the original behavior (collapse consecutive&#10;    // separators outside quotes, preserve spaces inside quotes).&#10;    let tokens = split_args_respecting_single_quotes(args);&#10;    if tokens.is_empty() {&#10;        String::new()&#10;    } else {&#10;        tokens.join(&quot; &quot;)&#10;    }&#10;}&#10;&#10;pub(crate) fn split_args_respecting_single_quotes(raw: &amp;str) -&gt; Vec&lt;String&gt; {&#10;    let mut result = Vec::new();&#10;    let mut current = String::new();&#10;    let mut in_quotes = false;&#10;&#10;    for c in raw.chars() {&#10;        match c {&#10;            '\'' =&gt; in_quotes = !in_quotes,&#10;            ' ' if !in_quotes =&gt; {&#10;                if !current.is_empty() {&#10;                    result.push(current.clone());&#10;                    current.clear();&#10;                }&#10;                // if current is empty, skip extra separators&#10;            }&#10;            ch =&gt; current.push(ch),&#10;        }&#10;    }&#10;&#10;    if !current.is_empty() {&#10;        result.push(current);&#10;    }&#10;&#10;    result&#10;}&#10;&#10;// Note: older helper `split_preprocessed_args` removed because callers should either use&#10;// `preprocess_args` (for builtins like `echo`) or `split_args_respecting_single_quotes` (for&#10;// external command argument lists). If needed, it can be reintroduced as a thin wrapper." />
              <option name="updatedContent" value="// Shared utilities for command argument preprocessing and splitting&#10;&#10;pub(crate) fn preprocess_args(args: &amp;str) -&gt; String {&#10;    // Reuse the splitter that respects single quotes to avoid duplicating parsing logic.&#10;    // Join tokens with a single space to match the original behavior (collapse consecutive&#10;    // separators outside quotes, preserve spaces inside quotes).&#10;    let tokens = split_args_respecting_single_quotes(args);&#10;    if tokens.is_empty() {&#10;        String::new()&#10;    } else {&#10;        tokens.join(&quot; &quot;)&#10;    }&#10;}&#10;&#10;pub(crate) fn split_args_respecting_single_quotes(raw: &amp;str) -&gt; Vec&lt;String&gt; {&#10;    let mut result = Vec::new();&#10;    let mut current = String::new();&#10;    let mut in_quotes = false;&#10;&#10;    for c in raw.chars() {&#10;        match c {&#10;            '\'' =&gt; in_quotes = !in_quotes,&#10;            ' ' if !in_quotes =&gt; {&#10;                if !current.is_empty() {&#10;                    result.push(current.clone());&#10;                    current.clear();&#10;                }&#10;                // if current is empty, skip extra separators&#10;            }&#10;            ch =&gt; current.push(ch),&#10;        }&#10;    }&#10;&#10;    if !current.is_empty() {&#10;        result.push(current);&#10;    }&#10;&#10;    result&#10;}&#10;&#10;// Note: older helper `split_preprocessed_args` removed because callers should either use&#10;// `preprocess_args` (for builtins like `echo`) or `split_args_respecting_single_quotes` (for&#10;// external command argument lists). If needed, it can be reintroduced as a thin wrapper." />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>